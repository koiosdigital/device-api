// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
  engineType = "client"
}

datasource db {
  provider = "postgresql"
}

enum DeviceType {
  LANTERN
  MATRX
}

enum ClaimType {
  OWNER
  SHARED
}

model Device {
  id                                String              @id
  type                              DeviceType
  lastSeenAt                        DateTime?
  currentlyDisplayingInstallationId String?
  deviceInfo                        Json?
  createdAt                         DateTime            @default(now())
  updatedAt                         DateTime            @updatedAt

  // Relations
  settings                        DeviceSettings?
  deviceClaims                    DeviceClaims[]
  currentlyDisplayingInstallation MatrxInstallation?  @relation("CurrentlyDisplaying", fields: [currentlyDisplayingInstallationId], references: [id], onDelete: SetNull)

  // Type-specific relations
  lanternGroupDevices LanternGroupDevices[]
  installations       MatrxInstallation[]      @relation("DeviceInstallations")
  shareInvites        DeviceShareInvite[]

  @@index([type])
  @@index([lastSeenAt])
  @@index([currentlyDisplayingInstallationId])
}

model DeviceClaims {
  id        Int      @id @default(autoincrement())
  deviceId  String
  userId    String 
  claimType ClaimType 
  claimedAt DateTime @default(now())

  // Relations
  device Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@unique([deviceId, userId])
  @@index([deviceId])
  @@index([userId])
}

model DeviceSettings {
  id          Int        @id @default(autoincrement())
  deviceId    String     @unique
  displayName String
  
  // Type-specific settings stored as JSON with validation
  typeSettings Json?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  device Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)
}

model LanternGroup {
  id        Int      @id @default(autoincrement())
  name      String
  ownerId   String
  joinCode  String   @unique @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  devices LanternGroupDevices[]

  @@index([ownerId])
}

model LanternGroupDevices {
  id                 Int    @id @default(autoincrement())
  groupId            Int
  deviceId           String
  triggeredSetEffect String @default("solid")
  triggeredSetColor  String @default("#000000")
  createdAt          DateTime @default(now())

  // Relations
  group  LanternGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)
  device Device       @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@unique([groupId, deviceId])
  @@index([groupId])
  @@index([deviceId])
}

model MatrxInstallation {
  id              String   @id @default(uuid())
  deviceId        String
  config          Json
  enabled         Boolean  @default(true)
  skippedByUser   Boolean  @default(false)
  skippedByServer Boolean  @default(false)
  pinnedByUser    Boolean  @default(false)
  displayTime     Int      @default(0)
  sortOrder       Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  device                 Device   @relation("DeviceInstallations", fields: [deviceId], references: [id], onDelete: Cascade)
  currentlyDisplayingFor Device[] @relation("CurrentlyDisplaying")

  @@index([deviceId])
  @@index([deviceId, sortOrder])
  @@index([deviceId, enabled])
}

model DeviceShareInvite {
  id          String   @id @default(uuid())
  deviceId    String
  inviterId   String   // User who created the invite
  targetEmail String   // Email address the invite was sent to
  expiresAt   DateTime // When the invite expires (24h from creation)
  acceptedAt  DateTime? // When the invite was accepted (null if pending)
  createdAt   DateTime @default(now())

  // Relations
  device Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@unique([deviceId, targetEmail]) // One active invite per device per email
  @@index([deviceId])
  @@index([targetEmail])
  @@index([expiresAt])
}